<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="CSC Summerschool">
  <title>Profiling and performance optimisation</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://mlouhivu.github.io/static-engine/reveal/3.5.0/css/reveal.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="theme/csc-2016/csc.css" id="theme">
  <link rel="stylesheet" href="theme/csc-2016/fonts.css">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'theme/csc-2016/pdf.css' : 'https://mlouhivu.github.io/static-engine/reveal/3.5.0/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="https://mlouhivu.github.io/static-engine/reveal/3.5.0/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section class="slide level1 title-slide" data-background-size="contain" data-background="theme/csc-2016/img/title-en.png">
  <h1>Profiling and performance optimisation</h1>
  <p>CSC Summerschool, 2019-07</p>
</section>

<section id="outline" class="slide level1" data-background-size="contain">
<h1>Outline</h1>
<ul>
<li>NVidia profiling tools</li>
<li>Tuning compute region performance
<ul>
<li>Enabling vectorization</li>
<li>Loop optimizations</li>
<li>Branches</li>
<li>Memory access</li>
</ul></li>
</ul>
</section>
<section id="profiling-tools" class="slide level1 section-slide" data-background-size="contain" data-background="theme/default/img/section.png">
<h1>Profiling tools</h1>
</section>
<section id="nvidia-nvprof-profiler" class="slide level1" data-background-size="contain">
<h1>NVIDIA NVPROF profiler</h1>
<ul>
<li>NVPROF is a command-line profiler that is included in OpenACC and CUDA toolkits
<ul>
<li>Can also do basic CPU profiling (CUDA 7.5 and newer)</li>
</ul></li>
<li>GPU profiling capabilities
<ul>
<li>High-level usage statistics</li>
<li>Timeline collection</li>
<li>Analysis metrics</li>
</ul></li>
</ul>
</section>
<section id="cpu-example" class="slide level1" data-background-size="contain">
<h1>CPU example</h1>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">nvprof</span> --cpu-profiling on --cpu-profiling-mode top-down ./cg

<span class="ex">...</span>

======== <span class="ex">CPU</span> profiling result (top down)<span class="bu">:</span>
<span class="ex">Time</span>(%) <span class="ex">Time</span>      Name
<span class="ex">79.56%</span>  26.7635s  main
<span class="ex">74.58%</span>  25.0876s  <span class="kw">|</span> <span class="ex">matvec</span>(matrix const <span class="kw">&amp;</span>, <span class="ex">vector</span> const <span class="kw">&amp;</span>, <span class="ex">vector</span> const <span class="kw">&amp;</span>)
 <span class="ex">4.89%</span>  1.64575s  <span class="kw">|</span> <span class="ex">allocate_3d_poisson_matrix</span>(matrix<span class="kw">&amp;</span>, <span class="ex">int</span>)
 <span class="ex">0.09%</span>  30.105ms  <span class="kw">|</span> <span class="ex">free_matrix</span>(matrix<span class="kw">&amp;</span>)
 <span class="ex">0.09%</span>  30.105ms  <span class="kw">|</span>   <span class="ex">munmap</span>
<span class="ex">15.96%</span>  5.36875s  waxpby(double, vector const <span class="kw">&amp;</span>, <span class="ex">double</span>, vector const <span class="kw">&amp;</span>, <span class="ex">vector</span> const <span class="kw">&amp;</span>)
 <span class="ex">4.18%</span>  1.40491s  dot(vector const <span class="kw">&amp;</span>, <span class="ex">vector</span> const <span class="kw">&amp;</span>)
 <span class="ex">0.27%</span>  90.315ms  __c_mset8
 <span class="ex">0.03%</span>  10.035ms  free_vector(vector<span class="kw">&amp;</span>)
 <span class="ex">0.03%</span>  10.035ms    munmap

======== <span class="ex">Data</span> collected at 100Hz frequency</code></pre></div>
</section>
<section id="gpu-example" class="slide level1" data-background-size="contain">
<h1>GPU example</h1>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">nvprof</span> ./cg
<span class="ex">...</span>

==<span class="ex">22639</span>== Profiling result:
<span class="ex">Time</span>(%)     <span class="ex">Time</span> Calls      Avg       Min       Max  Name
<span class="ex">84.96%</span>  3.73571s  101  36.987ms  36.952ms  37.003ms  matvec(matrix const <span class="kw">&amp;</span>, <span class="ex">...</span>
 <span class="ex">6.18%</span>  271.72ms  302  899.73us  598.47us  905.44us  waxpby(double, vector ...
 <span class="ex">5.40%</span>  237.64ms  389  610.91us     800ns  1.5132ms  [CUDA memcpy HtoD]
 <span class="ex">2.92%</span>  128.37ms  200  641.87us  535.49us  771.52us  dot(vector const <span class="kw">&amp;</span>, <span class="ex">...</span>
 <span class="ex">0.53%</span>  23.338ms  200  116.69us  116.03us  117.54us  dot(vector const <span class="kw">&amp;</span>, <span class="ex">...</span>
 <span class="ex">0.01%</span>  427.78us  200  2.1380us  1.8880us  11.488us  [CUDA memcpy DtoH]

==<span class="ex">22639</span>== API calls:
<span class="ex">Time</span>(%)     <span class="ex">Time</span> Calls      Avg       Min       Max  Name
<span class="ex">85.25%</span>  4.01764s  812  4.9478ms  2.2690us  37.097ms  cuStreamSynchronize
 <span class="ex">6.45%</span>  304.19ms    1  304.19ms  304.19ms  304.19ms  cuDevicePrimaryCtxRetain
 <span class="ex">3.43%</span>  161.86ms    1  161.86ms  161.86ms  161.86ms  cuDevicePrimaryCtxRelease
<span class="ex">...</span></code></pre></div>
</section>
<section id="nvidia-visual-profiler" class="slide level1" data-background-size="contain">
<h1>NVIDIA visual profiler</h1>
<figure>
<img src="img/nvidia-visual-profiler.png" class="center" />
</figure>
</section>
<section id="details-on-openacc-compute-construct" class="slide level1" data-background-size="contain">
<h1>Details on OpenACC compute construct</h1>
<figure>
<img src="img/profiler-compute-construct.png" class="center" />
</figure>
</section>
<section id="details-on-memory-copy" class="slide level1" data-background-size="contain">
<h1>Details on memory copy</h1>
<figure>
<img src="img/profiler-memory-copy.png" class="center" />
</figure>
</section>
<section id="optimization" class="slide level1 section-slide" data-background-size="contain" data-background="theme/default/img/section.png">
<h1>Optimization</h1>
</section>
<section id="compute-optimizations" class="slide level1" data-background-size="contain">
<h1>Compute optimizations</h1>
<ul>
<li>Data movement is and important part to optimize when using GPUs
<ul>
<li>Keeping data on the GPU as long as possible</li>
</ul></li>
<li>Getting the compiler to generate parallel code
<ul>
<li>Addressing loop dependencies</li>
</ul></li>
<li>Data access and execution divergence are important for GPU performance</li>
</ul>
</section>
<section id="loop-dependencies" class="slide level1" data-background-size="contain">
<h1>Loop dependencies</h1>
<div class="column">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* FLOW dependency, k&gt;0 */</span>
<span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;N; i++)
    A[i] = A[i-k]+<span class="dv">1</span>;
<span class="co">/* ANTI dependency, k&gt;0 */</span>
<span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;N; i++)
    A[i] = A[i+k]+<span class="dv">1</span>;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span class="co">! FLOW dependency, k&gt;0</span>
<span class="kw">do</span> i<span class="kw">=</span><span class="dv">0</span>, N
    a(i) <span class="kw">=</span> a(i<span class="kw">-</span>k) <span class="kw">+</span> <span class="dv">1</span>;
<span class="kw">end do</span>
<span class="co">! ANTI dependency, k&gt;0</span>
<span class="kw">do</span> i<span class="kw">=</span><span class="dv">0</span>, N
    a(i) <span class="kw">=</span> a(i<span class="kw">+</span>k) <span class="kw">+</span> <span class="dv">1</span>;
<span class="kw">end do</span></code></pre></div>
</div>
<div class="column">
<ul>
<li>FLOW dependency
<ul>
<li>Read After Write (RAW), data is written to is read on the following iteration round(s)</li>
</ul></li>
<li>ANTI dependency
<ul>
<li>Write After Read (WAR), data read is written to on the following iteration rounds</li>
</ul></li>
</ul>
</div>
</section>
<section id="loop-dependencies-1" class="slide level1" data-background-size="contain">
<h1>Loop dependencies</h1>
<ul>
<li>Dependencies disable vectorization, which is essential for good performance</li>
<li>Rewrite the loops so that the dependency is removed</li>
<li>Try to split the loop, use temporary array, etc.</li>
<li>Some dependencies can not be removed
<ul>
<li>Try a different algorithm?</li>
</ul></li>
</ul>
</section>
<section id="loop-dependencies-and-c" class="slide level1" data-background-size="contain">
<h1>Loop dependencies and C</h1>
<ul>
<li>C pointers are hard for the compiler to follow
<ul>
<li>Compiler will not know, if a loop can be vectorized safely, if a function has pointer arguments</li>
<li>Can be a <em>false</em> dependency</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> adder(<span class="dt">float</span> *x, <span class="dt">float</span> *y, <span class="dt">float</span> *res) {
    <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; VECSIZE; i++) {
        res[i] = x[i] + y[i];
    }
}</code></pre></div>
<ul>
<li>What if <code>res</code> and <code>x</code> overlap in memory?</li>
</ul>
</section>
<section id="c99-restrict-keyword" class="slide level1" data-background-size="contain">
<h1>C99 restrict keyword</h1>
<ul>
<li>C99 standard has restrict keyword which tells the compiler that the pointer is accessed so that it does not overlap with other accesses</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> adder(<span class="dt">float</span> <span class="dt">restrict</span> x, <span class="dt">float</span> <span class="dt">restrict</span> y, <span class="dt">float</span> <span class="dt">restrict</span> res) {
    <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; VECSIZE; i++) {
        res[i] = x[i] + y[i];
    }
}</code></pre></div>
</section>
<section id="loop-independent-clause" class="slide level1" data-background-size="contain">
<h1>Loop independent clause</h1>
<ul>
<li>OpenACC independent clause tells to the compiler that loop iterations are independent
<ul>
<li>Overrides any compiler dependency analysis</li>
<li>You have to make sure that the iterations are independent!</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#pragma acc loop independent</span>
<span class="dt">void</span> adder(<span class="dt">float</span> *x, <span class="dt">float</span> *y, <span class="dt">float</span> *res) {
    <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; VECSIZE; i++) {
        res[i] = x[i] + y[i];
    }
}</code></pre></div>
</section>
<section id="loop-directive" class="slide level1" data-background-size="contain">
<h1>Loop directive</h1>
<ul>
<li>Loop directive accepts several fine-tuning clauses
<ul>
<li><strong>gang</strong> -- apply gang-level parallelism</li>
<li><strong>worker</strong> -- apply worker-level parallelism</li>
<li><strong>vector</strong> -- apply vector-level parallelism</li>
<li><strong>seq</strong> -- run sequentially</li>
</ul></li>
<li>Multiple levels can be applied to a loop nest, but they have to be applied in top-down order</li>
</ul>
</section>
<section id="optimize-loops-vector-length" class="slide level1" data-background-size="contain">
<h1>Optimize loops: vector length</h1>
<ul>
<li>Tell the compiler that when using NVIDIA device it should use a vector length of 32 on the innermost loop</li>
<li>Because these parameters depend on the accelerator type, it is a good practice to add <strong>device_type</strong> clause</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;imax; i++) {
    ...
    <span class="pp">#pragma acc loop device_type(nvidia) vector(32)</span>
    <span class="cf">for</span> (<span class="dt">int</span> j=<span class="dv">0</span>; j&lt;jmax; j++) {
        ... <span class="co">/* No further loops in this block */</span>
    }
}</code></pre></div>
</section>
<section id="optimize-loops-specifying-workers" class="slide level1" data-background-size="contain">
<h1>Optimize loops: specifying workers</h1>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#pragma acc loop device_type(nvidia) gang worker(32)</span>
<span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;imax; i++) {
    ...
    <span class="pp">#pragma acc loop device_type(nvidia) vector(32)</span>
    <span class="cf">for</span> (<span class="dt">int</span> j=<span class="dv">0</span>; j&lt;jmax; j++) {
        ...
    }
}</code></pre></div>
<ul>
<li>Tell the compiler that when using NVIDIA device, the outer loop should be broken over gangs and workers with 32 workers per gang</li>
</ul>
</section>
<section id="additional-loop-optimizations" class="slide level1" data-background-size="contain">
<h1>Additional loop optimizations</h1>
<ul>
<li><code>collapse(N)</code>
<ul>
<li>Same as in OpenMP, take the next N tightly nested loops and flatten them into a one loop</li>
<li>Can be beneficial when loops are small</li>
<li>Breaks the next loops into tiles (blocks) before parallelizing the loops</li>
<li>For certain memory access patterns this can improve data locality</li>
</ul></li>
</ul>
</section>
<section id="what-values-should-i-try" class="slide level1" data-background-size="contain">
<h1>What values should I try?</h1>
<ul>
<li>Depends on the accelerator you are using</li>
<li>You can try out different combinations, but deterministic optimizations require good knowledge on the accelerator hardware
<ul>
<li>In the case of NVIDIA GPUs you should start with the NVVP results and refer to CUDA documentation</li>
<li>One hard-coded value: for NVIDIA GPUs the vector length should always be 32, which is the (current) warp size</li>
</ul></li>
</ul>
</section>
<section id="branches-in-device-code" class="slide level1" data-background-size="contain">
<h1>Branches in device code</h1>
<ul>
<li>32 threads running the same instruction at the same time</li>
<li>Avoid branches based on thread id unless evenly dividable by 32
<ul>
<li>If (i%2) NO!</li>
<li>if (i%32) ok</li>
</ul></li>
<li>When unavoidable keep branches short</li>
</ul>
</section>
<section id="coalesced-memory-access" class="slide level1" data-background-size="contain">
<h1>Coalesced memory access</h1>
<div class="column">
<ul>
<li>Coalesced memory access
<ul>
<li>32 threads accessing memory at the same time</li>
<li>32 Byte access granularity</li>
</ul></li>
<li>Overly simplified
<ul>
<li>Some cases 128 bytes access granularity</li>
<li>128 byte coalesced accesses can improve performance</li>
</ul></li>
</ul>
</div>
<div class="column">
<figure>
<img src="img/memory-access.png" />
</figure>
</div>
</section>
<section id="summary" class="slide level1" data-background-size="contain">
<h1>Summary</h1>
<ul>
<li>Profiling is essential for optimization
<ul>
<li>NVPROF and NVVP for NVIDIA platform</li>
</ul></li>
<li>Loop optimizations</li>
<li>Branches</li>
<li>Memory access patterns</li>
</ul>
</section>
    </div>
  </div>

  <script src="https://mlouhivu.github.io/static-engine/reveal/3.5.0/lib/js/head.min.js"></script>
  <script src="https://mlouhivu.github.io/static-engine/reveal/3.5.0/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: false,
        // Push each slide change to the browser history
        history: true,
        // Vertical centering of slides
        center: false,
        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom
        // Transition style for full page slide backgrounds
        backgroundTransition: 'none', // none/fade/slide/convex/concave/zoom
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1920,
        height: 1080,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'https://mlouhivu.github.io/static-engine/reveal/3.5.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'https://mlouhivu.github.io/static-engine/reveal/3.5.0/plugin/zoom-js/zoom.js', async: true },
          { src: 'https://mlouhivu.github.io/static-engine/reveal/3.5.0/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
